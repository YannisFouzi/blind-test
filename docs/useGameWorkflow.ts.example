import { useState, useEffect, useCallback, useMemo } from "react";
import { usePartyKitRoom } from "./usePartyKitRoom";
import { useWorksQuery } from "./queries/useWorksQuery";
import { useSongsQuery } from "./queries/useSongsQuery";
import { GameAnswer, Song } from "@/types";

/**
 * Options pour le hook useGameWorkflow
 */
type UseGameWorkflowOptions = {
  universeId: string;
  roomId?: string;
  playerId?: string;
  displayName?: string;
  allowedWorks?: string[];
  noSeek?: boolean;
  preloadNextTrack?: (song: Song) => void;
};

/**
 * Hook qui orchestre le workflow du jeu multiplayer avec TanStack Query
 *
 * Responsabilités :
 * - Charger works et songs via TanStack Query (cache automatique)
 * - Configurer la room PartyKit
 * - Auto-start le jeu après configuration
 * - Gérer l'état UI local (selectedWork, showAnswer, gameAnswer)
 * - Gérer les actions utilisateur (sélection, validation)
 *
 * Séparation des responsabilités :
 * - Data fetching : TanStack Query (useWorksQuery, useSongsQuery)
 * - WebSocket : usePartyKitRoom
 * - UI State : useState local dans ce hook
 * - Orchestration : ce hook
 *
 * @example
 * const game = useGameWorkflow({
 *   universeId,
 *   roomId,
 *   playerId,
 *   displayName,
 *   allowedWorks: ["work1", "work2"],
 *   noSeek: true,
 * });
 */
export const useGameWorkflow = ({
  universeId,
  roomId,
  playerId,
  displayName,
  allowedWorks = [],
  noSeek = false,
  preloadNextTrack,
}: UseGameWorkflowOptions) => {
  // ============================================================================
  // DATA FETCHING (TanStack Query)
  // ============================================================================

  // Charger les works de l'univers via TanStack Query
  const { data: works = [], isLoading: isLoadingWorks } = useWorksQuery(universeId);

  // Filtrer les works selon allowedWorks
  const worksToUse = useMemo(() => {
    if (allowedWorks.length > 0) {
      return works.filter((w) => allowedWorks.includes(w.id));
    }
    return works;
  }, [works, allowedWorks]);

  const workIds = worksToUse.map((w) => w.id);

  // Charger les songs pour les works filtrés via TanStack Query
  const { data: songs = [], isLoading: isLoadingSongs } = useSongsQuery(workIds);

  const isLoading = isLoadingWorks || isLoadingSongs;

  // ============================================================================
  // PARTYKIT CONNECTION (WebSocket)
  // ============================================================================

  const partyKit = usePartyKitRoom({ roomId, playerId, displayName });

  // ============================================================================
  // LOCAL UI STATE
  // ============================================================================

  const [selectedWork, setSelectedWork] = useState<string | null>(null);
  const [showAnswer, setShowAnswer] = useState(false);
  const [gameAnswer, setGameAnswer] = useState<GameAnswer | null>(null);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [lastGain, setLastGain] = useState<{ points: number; key: number } | null>(null);

  // ============================================================================
  // COMPUTED VALUES
  // ============================================================================

  const currentSongAnswer = useMemo(() => {
    if (!partyKit.currentSong || !playerId) return null;
    return (
      partyKit.responses.find(
        (r) => r.playerId === playerId && r.songId === partyKit.currentSong?.id
      ) ?? null
    );
  }, [partyKit.responses, playerId, partyKit.currentSong]);

  const isCurrentSongAnswered = Boolean(currentSongAnswer);

  // ============================================================================
  // SIDE EFFECTS
  // ============================================================================

  // Reset selection/answer on song change
  useEffect(() => {
    setSelectedWork(null);
    setGameAnswer(null);
    setShowAnswer(false);
    setLastGain(null);
  }, [partyKit.currentSong?.id]);

  // Reset selection si l'oeuvre sélectionnée n'est plus autorisée
  useEffect(() => {
    if (
      selectedWork &&
      partyKit.allowedWorks &&
      partyKit.allowedWorks.length > 0 &&
      !partyKit.allowedWorks.includes(selectedWork)
    ) {
      setSelectedWork(null);
    }
  }, [partyKit.allowedWorks, selectedWork]);

  // Preload next track
  useEffect(() => {
    if (
      partyKit.currentSong &&
      preloadNextTrack &&
      partyKit.room?.songs &&
      partyKit.room.songs[partyKit.currentSongIndex + 1]
    ) {
      const nextSong = partyKit.room.songs[partyKit.currentSongIndex + 1];
      setTimeout(() => preloadNextTrack(nextSong), 1000);
    }
  }, [
    partyKit.currentSong,
    preloadNextTrack,
    partyKit.room,
    partyKit.currentSongIndex,
  ]);

  // ============================================================================
  // ACTIONS (Handler functions)
  // ============================================================================

  const handleWorkSelection = useCallback(
    (workId: string) => {
      if (showAnswer || isCurrentSongAnswered) return;
      setSelectedWork(workId);
    },
    [showAnswer, isCurrentSongAnswered]
  );

  const handleValidateAnswer = useCallback(async () => {
    if (!partyKit.currentSong || !selectedWork) return;

    const isCorrect = selectedWork === partyKit.currentSong.workId;
    setSubmitError(null);

    try {
      const result = await partyKit.submitAnswer(selectedWork, isCorrect);

      if (result.success && result.data) {
        setGameAnswer({
          isCorrect,
          rank: result.data.rank,
          points: result.data.points,
        });
        setShowAnswer(true);

        if (result.data.points > 0) {
          setLastGain({ points: result.data.points, key: Date.now() });
        }
      } else {
        setSubmitError(result.error || "Erreur lors de la soumission");
        console.error("[useGameWorkflow] Submit error:", result.error);
      }
    } catch (error) {
      setSubmitError("Erreur lors de la soumission");
      console.error("[useGameWorkflow] Submit error:", error);
    }
  }, [partyKit.currentSong, selectedWork, partyKit]);

  // ============================================================================
  // RETURN (API publique du hook)
  // ============================================================================

  return {
    // PartyKit state (WebSocket)
    ...partyKit,

    // Works (TanStack Query)
    works: worksToUse,
    isLoadingWorks,

    // Songs (TanStack Query)
    songs,
    isLoadingSongs,

    // Combined loading state
    isLoading,

    // UI state
    selectedWork,
    showAnswer,
    gameAnswer,
    submitError,
    lastGain,
    currentSongAnswer,
    isCurrentSongAnswered,

    // Actions
    handleWorkSelection,
    handleValidateAnswer,
  };
};
